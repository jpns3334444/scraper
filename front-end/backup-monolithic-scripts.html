    
    <script>
        // Configuration
        // Single unified API endpoint for all frontend operations
        const API_URL = 'https://whxu6x5b08.execute-api.ap-northeast-1.amazonaws.com/prod';
        const FAVORITES_API_URL = API_URL; // Same API endpoint now
        const limit = 300;
        
        // State
        let cursor = null;          // null = first page; false = no more pages
        let loading = false;
        let allProperties = [];
        let filteredProperties = [];
        let currentSort = { field: 'price', direction: 'desc' };
        let currentPage = 1;
        let itemsPerPage = 100;
        let favorites = new Set();
        let hidden = new Set();
        let currentFilters = {
            ward: [],
            primary_light: [],
            verdict: []
        };
        
        // Authentication state
        let currentUser = null;
        
        // Authentication functions
        function checkAuth() {
            const savedEmail = localStorage.getItem('user_email');
            const savedToken = localStorage.getItem('auth_token');
            
            if (savedEmail && savedToken) {
                currentUser = { email: savedEmail, token: savedToken };
                document.getElementById('authModal').style.display = 'none';
                document.getElementById('userInfo').style.display = 'flex';
                document.getElementById('signInPrompt').style.display = 'none';
                document.getElementById('userEmail').textContent = savedEmail;
                return true;
            } else {
                // Don't force login - show sign in button instead
                document.getElementById('authModal').style.display = 'none';
                document.getElementById('userInfo').style.display = 'none';
                document.getElementById('signInPrompt').style.display = 'flex';
                return false;
            }
        }
        
        // Handle auth form submission
        document.getElementById('authForm').addEventListener('submit', async (e) => {
            e.preventDefault();
            const email = document.getElementById('email').value;
            const password = document.getElementById('password').value;
            const isLogin = document.getElementById('authTitle').textContent === 'Sign In';
            
            try {
                const endpoint = isLogin ? '/auth/login' : '/auth/register';
                const response = await fetch(FAVORITES_API_URL + endpoint, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ email, password })
                });
                
                const data = await response.json();
                
                if (data.success) {
                    localStorage.setItem('user_email', email);
                    localStorage.setItem('auth_token', data.token || email);
                    currentUser = { email, token: data.token || email };
                    document.getElementById('authModal').style.display = 'none';
                    document.getElementById('userInfo').style.display = 'flex';
                    document.getElementById('userEmail').textContent = email;
                    document.getElementById('authError').textContent = '';
                    
                    // Clear old anonymous favorites
                    localStorage.removeItem('favorites');
                    localStorage.removeItem('user_id');
                    favorites.clear();
                    
                    // Reload with authenticated user
                    loadFavoritesFromServer();
                    loadAllProperties();
                } else {
                    document.getElementById('authError').textContent = data.error || 'Authentication failed';
                }
            } catch (error) {
                document.getElementById('authError').textContent = 'Network error. Please try again.';
            }
        });
        
        // Toggle between login/register
        document.getElementById('authSwitchLink').addEventListener('click', (e) => {
            e.preventDefault();
            const isLogin = document.getElementById('authTitle').textContent === 'Sign In';
            
            if (isLogin) {
                document.getElementById('authTitle').textContent = 'Sign Up';
                document.getElementById('authSubmit').textContent = 'Sign Up';
                document.getElementById('authSwitchText').textContent = 'Already have an account?';
                document.getElementById('authSwitchLink').textContent = 'Sign In';
            } else {
                document.getElementById('authTitle').textContent = 'Sign In';
                document.getElementById('authSubmit').textContent = 'Sign In';
                document.getElementById('authSwitchText').textContent = "Don't have an account?";
                document.getElementById('authSwitchLink').textContent = 'Sign Up';
            }
            
            document.getElementById('authError').textContent = '';
        });
        
        function logout() {
            localStorage.clear();
            location.reload();
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', async function() {
            checkAuth();
            loadHiddenFromStorage();
            updateSortArrows();
            
            // Load properties first, then favorites to avoid race condition
            await loadAllProperties();
            
            if (currentUser) {
                await loadFavoritesFromServer();
            } else {
                loadFavoritesFromStorage();
            }
            
            updateFavoritesCount();
            updateHiddenCount();
            
            // Re-render favorites view if that tab is currently active
            if (document.getElementById('favorites-tab').classList.contains('active')) {
                await loadFavorites();
            }
        });
        
        // Load favorites from localStorage
        function loadFavoritesFromStorage() {
            const storedFavorites = localStorage.getItem('favorites');
            if (storedFavorites) {
                try {
                    favorites = new Set(JSON.parse(storedFavorites));
                } catch (e) {
                    favorites = new Set();
                }
            }
        }
        
        async function loadFavoritesFromServer() {
            if (!currentUser) return;
            
            try {
                const response = await fetch(`${FAVORITES_API_URL}/favorites/user/${currentUser.email}`, {
                    headers: { 
                        'X-User-Email': currentUser.email
                    }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.favorites && Array.isArray(data.favorites)) {
                        favorites = new Set(data.favorites.map(fav => fav.property_id));
                        updateFavoritesCount();
                        
                        // Re-render favorites view if that tab is currently active
                        if (document.getElementById('favorites-tab').classList.contains('active')) {
                            await loadFavorites();
                        }
                    }
                }
            } catch (error) {
                console.error('Failed to load favorites from server:', error);
            }
        }
        
        // Save favorites to localStorage
        function saveFavoritesToStorage() {
            localStorage.setItem('favorites', JSON.stringify([...favorites]));
        }
        
        // Get property image URL with fallback handling
        async function getPropertyImage(property) {
            // Check if property has image_url or image_key field
            if (property.image_url) {
                return property.image_url;
            } else if (property.image_key || property.image_s3_key) {
                // Generate pre-signed URL via API
                try {
                    const response = await fetch(`${API_URL}/properties/${property.property_id}/image-url`);
                    if (response.ok) {
                        const data = await response.json();
                        return data.presigned_url;
                    }
                } catch (error) {
                    console.error('Failed to get image URL:', error);
                }
            }
            return null;
        }
        
        // Load hidden from localStorage
        function loadHiddenFromStorage() {
            const storedHidden = localStorage.getItem('hidden');
            if (storedHidden) {
                try {
                    hidden = new Set(JSON.parse(storedHidden));
                } catch (e) {
                    hidden = new Set();
                }
            }
        }
        
        // Save hidden to localStorage
        function saveHiddenToStorage() {
            localStorage.setItem('hidden', JSON.stringify([...hidden]));
        }
        
        // Sync favorites with backend
        async function syncFavorites() {
            try {
                const response = await fetch(`${API_URL}/favorites/${getUserId()}`, {
                    headers: { 'X-User-Id': getUserId() }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    if (data.favorites && data.favorites.length > 0) {
                        // Get property IDs from backend favorites
                        const backendFavorites = new Set(data.favorites.map(f => f.property_id));
                        
                        // Merge with localStorage favorites
                        favorites = new Set([...favorites, ...backendFavorites]);
                        saveFavoritesToStorage();
                    }
                }
            } catch (error) {
                console.error('Failed to sync favorites:', error);
            }
        }
        
        async function fetchPropertiesPage(cursor) {
            const url = `${API_URL}/properties?limit=${limit}` +
                        (cursor ? `&cursor=${encodeURIComponent(JSON.stringify(cursor))}` : '');
            const res = await fetch(url, { 
                headers: { 'X-User-Id': getUserId() }
            });
            if (!res.ok) {
                console.error('Failed page:', await res.text());
                throw new Error(`Backend returned ${res.status}`);
            }
            const data = await res.json();
            // Map API's cursor field to nextCursor for frontend compatibility
            return {
                items: data.items,
                nextCursor: data.cursor || false
            };
        }

        function updateTableIncrementally(newItems) {
            // add only the new <tr>s; don't rebuild the whole table
            const tbody = document.querySelector('#propertiesTable');
            tbody.insertAdjacentHTML('beforeend', newItems.map(renderRow).join(''));
            updateCountersEtc(); // keep any totals / badge counts in sync
        }

        function updateCountersEtc() {
            // Update results count and pagination
            updateResultsInfo();
            renderPagination();
        }

        // Add global flag to track background loading state
        let isBackgroundLoading = false;
        let needsResort = false;

        // Recursive function to load all remaining pages in background
        async function loadRemainingPages(cursor) {
            if (!cursor) {
                console.log('No more pages to load');
                isBackgroundLoading = false;
                return;
            }
            
            isBackgroundLoading = true;
            console.log('Loading page with cursor:', cursor);
            
            try {
                const page = await fetchPropertiesPage(cursor);
                console.log('Loaded page, next cursor:', page.nextCursor);
                console.log('Page items count:', page.items?.length || 0);
                
                const filteredItems = page.items || [];
                
                console.log('Filtered items count:', filteredItems.length);
                
                // Update favorite status for new items
                filteredItems.forEach(property => {
                    property.is_favorited = favorites.has(property.property_id);
                });
                
                allProperties.push(...filteredItems);
                console.log('Total properties loaded so far:', allProperties.length);
                
                // Update filtered properties if no filters are active
                if (!hasActiveFilters()) {
                    filteredProperties.push(...filteredItems);
                    // Mark that a resort is needed but don't do it immediately during background loading
                    needsResort = true;
                    
                    // Only update UI subtly during background loading
                    if (document.getElementById('properties-tab').classList.contains('active')) {
                        // Just update the count without re-rendering
                        updateResultsInfo();
                        
                        // If user is on page 1, don't re-render at all to avoid flicker
                        // If on later pages, only update pagination
                        if (currentPage > 1) {
                            renderPagination();
                        }
                    }
                } else {
                    // Reapply filters to include new items
                    applyAllFilters();
                }
                
                // Continue loading next page
                if (page.nextCursor) {
                    console.log('Continuing to next page...');
                    loadRemainingPages(page.nextCursor);
                } else {
                    console.log('All pages loaded successfully!');
                    isBackgroundLoading = false;
                    // Now that all pages are loaded, apply sort if needed without flicker
                    if (needsResort && document.getElementById('properties-tab').classList.contains('active')) {
                        applySort();
                        needsResort = false;
                    }
                }
            } catch (error) {
                console.error('Background load failed', error);
                isBackgroundLoading = false;
                // Stop loading on error
            }
        }

        async function loadAllProperties() {
            loading = true;
            let cursor = null;
            
            try {
                // 1️⃣ fetch the first page
                const firstPage = await fetchPropertiesPage(cursor);
                
                // Items are now filtered server-side for price < 3000万円
                const filteredFirstPage = firstPage.items || [];
                
                allProperties.push(...filteredFirstPage);
                
                // Sync favorites with backend
                // await syncFavorites(); // Commented out - causing 404s
                
                // Update favorite status
                allProperties.forEach(property => {
                    property.is_favorited = favorites.has(property.property_id);
                });
                
                filteredProperties = [...allProperties];
                
                // Hide loading and show table immediately
                document.getElementById('loading').style.display = 'none';
                document.getElementById('tableContainer').style.display = 'block';
                
                // Apply initial sort and render first page
                applySort();
                renderCurrentPage();
                populateColumnFilters();
                
                cursor = firstPage.nextCursor; // may be null / false
                
                // 2️⃣ fire-and-forget the rest with recursive loading
                loadRemainingPages(cursor);
                
            } catch (error) {
                console.error('Error:', error);
                showErrorBanner('Connection error. Please refresh the page.');
            } finally {
                loading = false;
            }
        }
        
        // Render current page
        function renderCurrentPage() {
            // Don't re-render during background loading if user is on first page to avoid flicker
            if (isBackgroundLoading && currentPage === 1) {
                return;
            }
            
            const tbody = document.getElementById('propertiesTable');
            const start = (currentPage - 1) * itemsPerPage;
            const end = start + itemsPerPage;
            const pageItems = filteredProperties.slice(start, end);
            
            tbody.innerHTML = pageItems.map(renderRow).join('');
            
            updateResultsInfo();
            renderPagination();
            
            // Show/hide pagination container
            const paginationContainer = document.getElementById('paginationContainer');
            if (filteredProperties.length > 0) {
                paginationContainer.style.display = 'block';
            } else {
                paginationContainer.style.display = 'none';
            }
        }
        
        // Update results info
        function updateResultsInfo() {
            const start = (currentPage - 1) * itemsPerPage + 1;
            const end = Math.min(currentPage * itemsPerPage, filteredProperties.length);
            const filterText = hasActiveFilters() ? ' (filtered)' : '';
            
            document.getElementById('resultsCount').textContent = 
                `Showing ${start}-${end} of ${filteredProperties.length} properties${filterText}`;
        }
        
        // Check if filters are active
        function hasActiveFilters() {
            return currentFilters.ward.length > 0 || 
                   currentFilters.primary_light.length > 0 || 
                   currentFilters.verdict.length > 0;
        }
        
        function renderRow(property) {
            const price = formatPrice(property.price, '', true);
            const pricePerSqm = formatPrice(property.price_per_sqm);
            const monthyCost = formatPrice(property.total_monthly_costs);
            const ward = property.ward || '<span class="no-data">—</span>';
            const wardDiscount = formatPercent(property.ward_discount_pct);
            const wardMedian = formatPrice(property.ward_median_price_per_sqm);
            const closestStation = property.closest_station || '<span class="no-data">—</span>';
            const walkTime = property.station_distance_minutes 
                ? `${property.station_distance_minutes}`
                : '<span class="no-data">—</span>';
            const floor = property.floor || '<span class="no-data">—</span>';
            const buildingAge = property.building_age_years !== undefined 
                ? `${property.building_age_years} years`
                : '<span class="no-data">—</span>';
            const size = property.size_sqm || property.total_sqm 
                ? `${Math.round(property.size_sqm || property.total_sqm)}`
                : '<span class="no-data">—</span>';
            const primaryLight = property.primary_light || '<span class="no-data">—</span>';
            const verdict = property.verdict || property.recommendation || 'pass';
            const hasLink = property.listing_url && property.listing_url.trim();
            const isFavorited = favorites.has(property.property_id);
            const isHidden = hidden.has(property.property_id);
            
            return `
                <tr ${hasLink ? `onclick="openListing(event, '${property.listing_url}')"` : 'class="no-link"'} data-property-id="${property.property_id}">
                    <td style="text-align: center; white-space: nowrap;">
                        <button class="heart-btn ${isFavorited ? 'favorited' : ''}" 
                                onclick="toggleFavorite('${property.property_id}', this)"
                                data-property-id="${property.property_id}">
                            ${isFavorited ? '♥' : '♡'}
                        </button>
                        <button class="hide-btn" 
                                onclick="toggleHidden('${property.property_id}', this)"
                                data-property-id="${property.property_id}">
                            ✕
                        </button>
                    </td>
                    <td class="price">${price}</td>
                    <td class="price">${pricePerSqm}</td>
                    <td class="price">${monthyCost}</td>
                    <td>${ward}</td>
                    <td class="percent">${wardDiscount}</td>
                    <td class="price">${wardMedian}</td>
                    <td>${closestStation}</td>
                    <td class="numeric">${walkTime}</td>
                    <td class="numeric">${floor}</td>
                    <td class="age">${buildingAge}</td>
                    <td class="numeric">${size}</td>
                    <td>${primaryLight}</td>
                    <td>
                        <span class="verdict verdict-${verdict}">${verdict.toUpperCase()}</span>
                    </td>
                </tr>
            `;
        }
        
        // Sorting
        function sortTable(field) {
            // Toggle direction if same field, otherwise start with desc
            if (currentSort.field === field) {
                currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                currentSort.field = field;
                currentSort.direction = 'desc';
            }
            
            // Apply deferred sort if needed
            if (needsResort) {
                needsResort = false;
            }
            
            applySort();
            currentPage = 1;
            renderCurrentPage();
        }
        
        // Apply sort to filtered properties
        function applySort() {
            filteredProperties.sort((a, b) => {
                let valA = a[currentSort.field];
                let valB = b[currentSort.field];
                
                // Handle null/undefined values
                if (valA == null && valB == null) return 0;
                if (valA == null) return 1;
                if (valB == null) return -1;
                
                // Convert to numbers for numeric fields
                if (typeof valA === 'string' && !isNaN(valA)) valA = parseFloat(valA);
                if (typeof valB === 'string' && !isNaN(valB)) valB = parseFloat(valB);
                
                let result = 0;
                if (valA < valB) result = -1;
                else if (valA > valB) result = 1;
                
                return currentSort.direction === 'asc' ? result : -result;
            });
            
            updateSortArrows();
        }
        
        function updateSortArrows() {
            // Reset all arrows
            document.querySelectorAll('.sort-arrows').forEach(arrow => {
                arrow.classList.remove('active');
                arrow.textContent = '▲▼';
            });
            
            // Set active arrow
            const activeArrow = document.getElementById(`sort-${currentSort.field}`);
            if (activeArrow) {
                activeArrow.classList.add('active');
                activeArrow.textContent = currentSort.direction === 'asc' ? '▲' : '▼';
            }
        }
        
        // Utility functions
        function formatPrice(price, suffix = '', multiplyBy10k = false) {
            if (!price && price !== 0) return '<span class="no-data">—</span>';
            // Only multiply by 10,000 for main price column (prices stored in 万円)
            const actualPrice = multiplyBy10k ? price * 10000 : price;
            return '¥' + Math.round(actualPrice).toLocaleString() + suffix;
        }
        
        function formatPercent(percent) {
            if (percent === undefined || percent === null) return '<span class="no-data">—</span>';
            const formatted = percent.toFixed(1);
            return formatted > 0 ? `+${formatted}%` : `${formatted}%`;
        }

        // User ID management
        function getUserId() {
            // Use authenticated user email if available, otherwise fallback to anonymous
            if (currentUser) {
                return currentUser.email;
            }
            
            let userId = localStorage.getItem('user_id');
            if (!userId) {
                userId = 'user_' + Math.random().toString(36).substr(2, 9);
                localStorage.setItem('user_id', userId);
            }
            return userId;
        }

        // Tab functionality
        async function switchTab(tabName) {
            console.log(`[DEBUG] ========== SWITCHING TO TAB: ${tabName} ==========`);
            
            // Log state before switching
            console.log('[DEBUG] Tab states BEFORE switch:');
            document.querySelectorAll('.tab-pane').forEach(pane => {
                console.log(`  - ${pane.id}: display=${pane.style.display}, active=${pane.classList.contains('active')}`);
            });
            
            // Remove active class from all panes
            document.querySelectorAll('.tab-pane').forEach(pane => {
                pane.classList.remove('active');
                pane.style.display = 'none'; // Explicitly set display:none
            });
            
            // Remove active from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Activate the selected tab
            const targetTab = document.getElementById(`${tabName}-tab`);
            console.log(`[DEBUG] Activating tab: ${tabName}-tab`);
            targetTab.classList.add('active');
            targetTab.style.display = 'block'; // Explicitly set display:block
            
            // Activate the button
            event.target.classList.add('active');
            
            // Log state after switching
            console.log('[DEBUG] Tab states AFTER switch:');
            document.querySelectorAll('.tab-pane').forEach(pane => {
                console.log(`  - ${pane.id}: display=${pane.style.display}, active=${pane.classList.contains('active')}`);
            });
            
            if (tabName === 'favorites') {
                console.log('[DEBUG] Loading favorites tab content...');
                document.getElementById('tableContainer').style.display = 'none';
                document.getElementById('loading').style.display = 'none';
                document.getElementById('paginationContainer').style.display = 'none';
                await loadFavorites();
                console.log('[DEBUG] Favorites tab loaded');
                
                // Check if content is visible
                const favList = document.getElementById('favoritesList');
                console.log(`[DEBUG] favoritesList element: exists=${!!favList}, innerHTML length=${favList?.innerHTML?.length}`);
                console.log(`[DEBUG] favoritesList computed style:`, window.getComputedStyle(favList));
            } else if (tabName === 'hidden') {
                console.log('[DEBUG] Loading hidden tab content...');
                document.getElementById('tableContainer').style.display = 'none';
                document.getElementById('loading').style.display = 'none';
                document.getElementById('paginationContainer').style.display = 'none';
                loadHidden();
                console.log('[DEBUG] Hidden tab loaded');
                
                // Check if content is visible
                const hiddenList = document.getElementById('hiddenList');
                console.log(`[DEBUG] hiddenList element: exists=${!!hiddenList}, innerHTML length=${hiddenList?.innerHTML?.length}`);
                console.log(`[DEBUG] hiddenList computed style:`, window.getComputedStyle(hiddenList));
            } else {
                console.log('[DEBUG] Showing main properties table');
                document.getElementById('tableContainer').style.display = 'block';
                document.getElementById('paginationContainer').style.display = 'block';
            }
            
            console.log(`[DEBUG] ========== TAB SWITCH COMPLETE ==========`);
        }
        
        // Helper for instant favorites counter update
        function deltaFavorites(delta) {
            const el = document.getElementById('favoritesCount');
            el.textContent = Math.max(0, (parseInt(el.textContent) || 0) + delta);
        }

        // Open listing in new tab
        function openListing(event, url) {
            // Don't open if clicking on buttons or other interactive elements
            if (event.target.tagName === 'BUTTON' || event.target.closest('button')) {
                return;
            }
            window.open(url, '_blank');
        }
        
        // Toggle favorite
        async function toggleFavorite(propertyId, button) {
            event.stopPropagation();
            button.disabled = true;
            const isFavorited = button.classList.contains('favorited');
            
            try {
                if (!currentUser) {
                    // Anonymous user - use localStorage
                    if (isFavorited) {
                        favorites.delete(propertyId);
                        button.classList.remove('favorited');
                        button.textContent = '♡';
                    } else {
                        favorites.add(propertyId);
                        button.classList.add('favorited');
                        button.textContent = '♥';
                    }
                    saveFavoritesToStorage();
                    deltaFavorites(isFavorited ? -1 : 1);
                } else {
                    // Authenticated user - use API
                    if (isFavorited) {
                        await fetch(`${FAVORITES_API_URL}/favorites/${propertyId}`, {
                            method: 'DELETE',
                            headers: { 
                                'X-User-Email': currentUser.email
                            }
                        });
                        button.classList.remove('favorited');
                        button.textContent = '♡';
                        favorites.delete(propertyId);
                        deltaFavorites(-1);
                    } else {
                        await fetch(`${FAVORITES_API_URL}/favorites`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'X-User-Email': currentUser.email
                            },
                            body: JSON.stringify({ property_id: propertyId })
                        });
                        button.classList.add('favorited');
                        button.textContent = '♥';
                        favorites.add(propertyId);
                        deltaFavorites(+1);
                    }
                }
                
                // Update property status
                const property = allProperties.find(p => p.property_id === propertyId);
                if (property) property.is_favorited = !isFavorited;
                
                // Refresh favorites tab if active
                if (document.getElementById('favorites-tab').classList.contains('active')) {
                    await loadFavorites();
                }
            } catch (error) {
                console.error('Failed to toggle favorite:', error);
            } finally {
                button.disabled = false;
            }
        }
        
        // Remove favorite from favorites tab
        async function removeFavorite(propertyId) {
            if (!confirm('Remove this property from favorites?')) return;
            
            try {
                // Call the same toggle function
                const heartBtn = document.querySelector(`button[data-property-id="${propertyId}"]`);
                if (heartBtn && heartBtn.classList.contains('favorited')) {
                    await toggleFavorite(propertyId, heartBtn);
                } else {
                    // Direct removal if not in main view
                    if (currentUser) {
                        await fetch(`${FAVORITES_API_URL}/favorites/${propertyId}`, {
                            method: 'DELETE',
                            headers: { 'X-User-Email': currentUser.email }
                        });
                    }
                    favorites.delete(propertyId);
                    saveFavoritesToStorage();
                    updateFavoritesCount();
                }
                
                // Animate removal from favorites view
                const card = document.querySelector(`.favorite-card[data-property-id="${propertyId}"]`);
                if (card) {
                    card.style.transition = 'all 0.3s';
                    card.style.opacity = '0';
                    card.style.transform = 'translateX(-100%)';
                    setTimeout(() => {
                        card.remove();
                        // Check if no favorites left
                        if (document.querySelectorAll('.favorite-card').length === 0) {
                            document.querySelector('.favorites-container').innerHTML = 
                                '<div style="padding:40px; text-align:center; color:#999;">No favorites yet</div>';
                        }
                    }, 300);
                }
            } catch (error) {
                console.error('Failed to remove favorite:', error);
                alert('Failed to remove favorite. Please try again.');
            }
        }

        // Load favorites view
        async function loadFavorites() {
            console.log('[DEBUG] ========== LOAD FAVORITES START ==========');
            const list = document.getElementById('favoritesList');
            console.log(`[DEBUG] favoritesList element found: ${!!list}`);
            console.log(`[DEBUG] Current user: ${currentUser ? currentUser.email : 'Anonymous'}`);
            console.log(`[DEBUG] Favorites Set contents:`, [...favorites]);
            console.log(`[DEBUG] Favorites Set size: ${favorites.size}`);
            console.log(`[DEBUG] All properties count: ${allProperties.length}`);
            
            if (!currentUser) {
                console.log('[DEBUG] Anonymous user path');
                // Anonymous user - use localStorage favorites
                if (allProperties.length === 0) {
                    console.log('[DEBUG] No properties loaded yet, showing loading message');
                    list.innerHTML = '<div style="padding:40px; text-align:center; color:#999;">Loading properties...</div>';
                    return;
                }
                
                const favoritedProperties = allProperties.filter(p => favorites.has(p.property_id));
                console.log(`[DEBUG] Filtered properties: ${favoritedProperties.length} favorites found`);
                console.log('[DEBUG] Favorited property IDs:', favoritedProperties.map(p => p.property_id));
                
                if (favoritedProperties.length === 0) {
                    console.log('[DEBUG] No favorites, showing empty message');
                    list.innerHTML = '<div style="padding:40px; text-align:center; color:#999;">No favorites yet</div>';
                    console.log(`[DEBUG] After setting innerHTML, list content length: ${list.innerHTML.length}`);
                    return;
                }
                
                // Sort favorited properties by price descending
                favoritedProperties.sort((a, b) => (b.price || 0) - (a.price || 0));
                console.log('[DEBUG] Properties sorted by price');
                
                // Generate card HTML for each property
                const cardPromises = favoritedProperties.map(async property => {
                    const price = property.price ? `¥${(property.price * 10000).toLocaleString()}` : '—';
                    const size = property.size_sqm || property.total_sqm ? 
                        `${Math.round(property.size_sqm || property.total_sqm)}m²` : '—';
                    const ward = property.ward || '—';
                    const wardDiscount = property.ward_discount_pct;
                    const wardDiscountText = wardDiscount !== undefined && wardDiscount !== null ? 
                        (wardDiscount > 0 ? `+${wardDiscount.toFixed(1)}%` : `${wardDiscount.toFixed(1)}%`) : '';
                    const station = property.closest_station || 'No station';
                    const verdict = property.verdict || property.recommendation || 'pass';
                    const url = property.listing_url || '#';
                    
                    // Get property image
                    const imageUrl = await getPropertyImage(property);
                    const imageHtml = imageUrl ? 
                        `<img src="${imageUrl}" alt="Property image" onError="this.parentElement.classList.add('no-image'); this.parentElement.innerHTML='No Image';">` : 
                        '<div class="no-image">No Image</div>';
                    
                    // Determine processing status
                    let statusClass = 'processing';
                    let statusText = 'Processing';
                    if (property.analysis_status === 'completed' || property.verdict) {
                        statusClass = 'processed';
                        statusText = 'Processed';
                    } else if (property.analysis_status === 'failed') {
                        statusClass = 'failed';
                        statusText = 'Failed';
                    }
                    
                    return `
                        <div class="favorite-card" data-property-id="${property.property_id}" onclick="openListing(event, '${url}')" style="cursor: pointer;">
                            <div class="favorite-image-section">
                                ${imageHtml}
                            </div>
                            <div class="favorite-details-section">
                                <div class="favorite-ward">${ward}${wardDiscountText ? ` (${wardDiscountText})` : ''}</div>
                                <div class="favorite-price">${price}</div>
                                <div class="favorite-size">${size} • ${station}</div>
                            </div>
                            <div class="favorite-status-section">
                                <span class="processing-status ${statusClass}">${statusText}</span>
                            </div>
                            <button class="remove-favorite-btn" onclick="event.stopPropagation(); removeFavorite('${property.property_id}')" title="Remove from favorites">
                                <svg width="16" height="16" viewBox="0 0 16 16">
                                    <path d="M2 2l12 12M14 2L2 14" stroke="currentColor" stroke-width="2"/>
                                </svg>
                            </button>
                        </div>`;
                });
                
                const cards = await Promise.all(cardPromises);
                const htmlContent = cards.join('');
                
                console.log(`[DEBUG] Generated HTML content length: ${htmlContent.length} chars`);
                console.log('[DEBUG] First 200 chars of HTML:', htmlContent.substring(0, 200));
                
                list.innerHTML = htmlContent;
                console.log(`[DEBUG] After setting innerHTML, list content length: ${list.innerHTML.length}`);
            } else {
                console.log('[DEBUG] Authenticated user path');
                // Authenticated user - fetch favorites from API
                try {
                    console.log('[DEBUG] Setting loading message');
                    list.innerHTML = '<div style="padding:40px; text-align:center; color:#999;">Loading favorites...</div>';
                    
                    console.log(`[DEBUG] Fetching favorites from API for user: ${currentUser.email}`);
                    const response = await fetch(`${FAVORITES_API_URL}/favorites/user/${currentUser.email}`, {
                        headers: { 
                            'X-User-Email': currentUser.email
                        }
                    });
                    
                    console.log(`[DEBUG] API Response status: ${response.status}`);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    
                    const data = await response.json();
                    const userFavorites = data.favorites || [];
                    
                    console.log('[DEBUG] Loaded favorites from API:', userFavorites);
                    console.log(`[DEBUG] Number of favorites from API: ${userFavorites.length}`);
                    console.log('[DEBUG] Current allProperties count:', allProperties.length);
                    
                    if (userFavorites.length === 0) {
                        console.log('[DEBUG] No favorites from API, showing empty message');
                        list.innerHTML = '<div style="padding:40px; text-align:center; color:#999;">No favorites yet</div>';
                        console.log(`[DEBUG] After setting empty message, list content length: ${list.innerHTML.length}`);
                        return;
                    }
                    
                    // For authenticated users, we need to match favorites with properties from allProperties
                    // to get full property data since favorites API only stores summaries
                    const favoritedProperties = [];
                    
                    console.log('[DEBUG] Matching favorites with allProperties...');
                    for (const favorite of userFavorites) {
                        const propertyId = favorite.property_id;
                        let property = allProperties.find(p => p.property_id === propertyId);
                        
                        if (property) {
                            console.log(`[DEBUG] Found property in allProperties: ${propertyId}`);
                            favoritedProperties.push(property);
                        } else {
                            // If property not found in allProperties, use the summary from favorites
                            console.log(`[DEBUG] Property not found in allProperties, using summary: ${propertyId}`);
                            const summary = favorite.property_summary || {};
                            favoritedProperties.push({
                                property_id: propertyId,
                                price: summary.price || 1, // Use 1 instead of 0 to show something
                                size_sqm: summary.size_sqm || 0,
                                ward: summary.ward || 'Unknown Ward',
                                closest_station: summary.station || 'Unknown Station',
                                verdict: 'favorited',
                                listing_url: '#',
                                isFallback: true
                            });
                        }
                    }
                    
                    // Sort by price descending
                    favoritedProperties.sort((a, b) => (b.price || 0) - (a.price || 0));
                    
                    console.log('[DEBUG] Final favoritedProperties to display:', favoritedProperties);
                    console.log(`[DEBUG] Total matched properties: ${favoritedProperties.length}`);
                    
                    if (favoritedProperties.length === 0) {
                        console.log('[DEBUG] No properties matched, showing no matching message');
                        list.innerHTML = '<div style="padding:40px; text-align:center; color:#999;">Favorites found but no matching properties.</div>';
                        return;
                    }
                    
                    console.log('[DEBUG] Generating card HTML for favorited properties...');
                    // Generate card HTML for each property
                    const cardPromises = favoritedProperties.map(async property => {
                        const price = property.price ? `¥${(property.price * 10000).toLocaleString()}` : '—';
                        const size = property.size_sqm || property.total_sqm ? 
                            `${Math.round(property.size_sqm || property.total_sqm)}m²` : '—';
                        const ward = property.ward || '—';
                        const wardDiscount = property.ward_discount_pct;
                        const wardDiscountText = wardDiscount !== undefined && wardDiscount !== null ? 
                            (wardDiscount > 0 ? `+${wardDiscount.toFixed(1)}%` : `${wardDiscount.toFixed(1)}%`) : '';
                        const station = property.closest_station || 'No station';
                        const verdict = property.verdict || property.recommendation || 'unknown';
                        const url = property.listing_url || '#';
                        
                        // Special display for fallback properties
                        const displayWard = property.isFallback ? 
                            `Property ID: ${property.property_id}` : ward;
                        const displayPrice = property.isFallback ? '(data not available)' : price;
                        const displaySize = property.isFallback ? '' : size;
                        
                        // Get property image (skip for fallback properties)
                        const imageUrl = property.isFallback ? null : await getPropertyImage(property);
                        const imageHtml = imageUrl ? 
                            `<img src="${imageUrl}" alt="Property image" onError="this.parentElement.classList.add('no-image'); this.parentElement.innerHTML='No Image';">` : 
                            '<div class="no-image">No Image</div>';
                        
                        // Determine processing status
                        let statusClass = 'processing';
                        let statusText = 'Processing';
                        if (property.isFallback || property.analysis_status === 'completed' || property.verdict) {
                            statusClass = 'processed';
                            statusText = 'Processed';
                        } else if (property.analysis_status === 'failed') {
                            statusClass = 'failed';
                            statusText = 'Failed';
                        }
                        
                        return `
                            <div class="favorite-card" data-property-id="${property.property_id}" onclick="openListing(event, '${url}')" style="cursor: pointer;">
                                <div class="favorite-image-section">
                                    ${imageHtml}
                                </div>
                                <div class="favorite-details-section">
                                    <div class="favorite-ward">${displayWard}${wardDiscountText ? ` (${wardDiscountText})` : ''}</div>
                                    <div class="favorite-price">${displayPrice}</div>
                                    <div class="favorite-size">${displaySize ? `${displaySize} • ` : ''}${station}</div>
                                </div>
                                <div class="favorite-status-section">
                                    <span class="processing-status ${statusClass}">${statusText}</span>
                                </div>
                                <button class="remove-favorite-btn" onclick="event.stopPropagation(); removeFavorite('${property.property_id}')" title="Remove from favorites">
                                    <svg width="16" height="16" viewBox="0 0 16 16">
                                        <path d="M2 2l12 12M14 2L2 14" stroke="currentColor" stroke-width="2"/>
                                    </svg>
                                </button>
                            </div>`;
                    });
                    
                    const cards = await Promise.all(cardPromises);
                    const htmlContent = cards.join('');
                    
                    console.log(`[DEBUG] Generated HTML content length: ${htmlContent.length} chars`);
                    console.log('[DEBUG] First 200 chars of HTML:', htmlContent.substring(0, 200));
                    
                    list.innerHTML = htmlContent;
                    console.log(`[DEBUG] After setting innerHTML, list content length: ${list.innerHTML.length}`);
                    
                } catch (error) {
                    console.error('[DEBUG] Failed to load favorites:', error);
                    list.innerHTML = `<div style="padding:40px; text-align:center; color:#999;">Failed to load favorites: ${error.message}</div>`;
                }
            }
            
            // Update debug counter
            const debugCount = document.getElementById('favDebugCount');
            if (debugCount) {
                debugCount.textContent = `Items in list: ${document.querySelectorAll('.favorite-card').length}`;
            }
            
            console.log('[DEBUG] ========== LOAD FAVORITES END ==========');
        }

        // Update favorites count from localStorage
        function updateFavoritesCount() {
            document.getElementById('favoritesCount').textContent = favorites.size;
        }
        
        // Update hidden count
        function updateHiddenCount() {
            document.getElementById('hiddenCount').textContent = hidden.size;
        }
        
        // Toggle hidden
        function toggleHidden(propertyId, button) {
            event.stopPropagation();
            button.disabled = true;
            
            if (hidden.has(propertyId)) {
                hidden.delete(propertyId);
            } else {
                hidden.add(propertyId);
                
                // Immediately remove the row from DOM for better UX
                const rows = document.querySelectorAll(`tr[data-property-id="${propertyId}"]`);
                rows.forEach(row => {
                    row.style.transition = 'opacity 0.3s, transform 0.3s';
                    row.style.opacity = '0';
                    row.style.transform = 'translateX(-100%)';
                    setTimeout(() => row.remove(), 300);
                });
            }
            
            saveHiddenToStorage();
            updateHiddenCount();
            
            // Apply filters to update the view
            if (document.getElementById('properties-tab').classList.contains('active')) {
                applyAllFilters();
            }
            
            button.disabled = false;
        }
        
        // Load hidden view
        function loadHidden() {
            console.log('[DEBUG] ========== LOAD HIDDEN START ==========');
            const list = document.getElementById('hiddenList');
            console.log(`[DEBUG] hiddenList element found: ${!!list}`);
            console.log(`[DEBUG] Hidden Set contents:`, [...hidden]);
            console.log(`[DEBUG] Hidden Set size: ${hidden.size}`);
            console.log(`[DEBUG] All properties count: ${allProperties.length}`);
            
            // Check if properties are loaded
            if (allProperties.length === 0) {
                console.log('[DEBUG] No properties loaded yet, showing loading message');
                list.innerHTML = '<li style="padding:20px; color:#999;">Loading properties...</li>';
                // Try again after a short delay
                setTimeout(() => {
                    console.log('[DEBUG] Retrying loadHidden after delay...');
                    if (allProperties.length > 0) {
                        loadHidden();
                    }
                }, 500);
                return;
            }
            
            // Get hidden properties from the full list
            const hiddenProperties = allProperties.filter(p => hidden.has(p.property_id));
            console.log(`[DEBUG] Filtered properties: ${hiddenProperties.length} hidden found`);
            console.log('[DEBUG] Hidden property IDs:', hiddenProperties.map(p => p.property_id));
            
            if (hiddenProperties.length === 0) {
                console.log('[DEBUG] No hidden properties, showing empty message');
                list.innerHTML = '<li style="padding:20px; color:#999;">No hidden properties.</li>';
                console.log(`[DEBUG] After setting empty message, list content length: ${list.innerHTML.length}`);
                return;
            }
            
            // Sort hidden properties by price descending
            hiddenProperties.sort((a, b) => (b.price || 0) - (a.price || 0));
            console.log('[DEBUG] Properties sorted by price');
            
            console.log('[DEBUG] Generating HTML for hidden properties...');
            const htmlContent = hiddenProperties.map(property => {
                const price = property.price ? `¥${(property.price * 10000).toLocaleString()}` : '—';
                const size = property.size_sqm || property.total_sqm ? 
                    `${Math.round(property.size_sqm || property.total_sqm)}m²` : '—';
                const ward = property.ward || '—';
                const wardDiscount = property.ward_discount_pct;
                const wardDiscountText = wardDiscount !== undefined && wardDiscount !== null ? 
                    (wardDiscount > 0 ? `+${wardDiscount.toFixed(1)}%` : `${wardDiscount.toFixed(1)}%`) : '';
                const station = property.closest_station || 'No station';
                const verdict = property.verdict || property.recommendation || 'pass';
                const url = property.listing_url || '#';
                
                return `
                    <li class="fav-item">
                        <span>
                            <a href="${url}" target="_blank" style="color: #333; text-decoration: none;">
                                ${price}
                            </a>
                            — ${size}
                            — ${ward}${wardDiscountText ? ` (${wardDiscountText})` : ''}
                            — ${station}
                            <button class="hide-btn" 
                                    onclick="toggleHidden('${property.property_id}', this)"
                                    style="margin-left: 10px;"
                                    title="Unhide this property">
                                ↺
                            </button>
                        </span>
                        <span class="verdict verdict-${verdict}" style="font-size: 11px;">
                            ${verdict.toUpperCase()}
                        </span>
                    </li>`;
            }).join('');
            
            console.log(`[DEBUG] Generated HTML content length: ${htmlContent.length} chars`);
            console.log('[DEBUG] First 200 chars of HTML:', htmlContent.substring(0, 200));
            
            list.innerHTML = htmlContent;
            console.log(`[DEBUG] After setting innerHTML, list content length: ${list.innerHTML.length}`);
            console.log('[DEBUG] List element visibility:', {
                display: list.style.display,
                computedDisplay: window.getComputedStyle(list).display,
                visibility: window.getComputedStyle(list).visibility,
                opacity: window.getComputedStyle(list).opacity,
                parentDisplay: window.getComputedStyle(list.parentElement).display
            });
            
            // Update debug counter
            const debugCount = document.getElementById('hiddenDebugCount');
            if (debugCount) {
                debugCount.textContent = `Items in list: ${list.children.length}`;
            }
            
            console.log('[DEBUG] ========== LOAD HIDDEN END ==========');
        }

        // View property details (placeholder)
        function viewProperty(propertyId) {
            // Find the property in allProperties
            const property = allProperties.find(p => p.property_id === propertyId);
            if (property && property.listing_url) {
                window.open(property.listing_url, '_blank');
            } else {
                alert('Property details not available');
            }
        }
        
        // View analysis (placeholder for future implementation)
        function viewAnalysis(propertyId) {
            // This would navigate to the analysis page once implemented
            alert('Analysis view coming soon!');
        }
        
        // Render pagination
        function renderPagination() {
            const totalPages = Math.ceil(filteredProperties.length / itemsPerPage);
            const paginationDiv = document.getElementById('pagination');
            
            if (totalPages <= 1) {
                paginationDiv.innerHTML = '';
                return;
            }
            
            let html = '';
            
            // Previous button
            html += `<button onclick="goToPage(${currentPage - 1})" ${currentPage === 1 ? 'disabled' : ''}>Previous</button>`;
            
            // Page numbers
            const maxVisiblePages = 7;
            let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
            let endPage = Math.min(totalPages, startPage + maxVisiblePages - 1);
            
            if (endPage - startPage < maxVisiblePages - 1) {
                startPage = Math.max(1, endPage - maxVisiblePages + 1);
            }
            
            if (startPage > 1) {
                html += `<button onclick="goToPage(1)">1</button>`;
                if (startPage > 2) html += '<span class="page-info">...</span>';
            }
            
            for (let i = startPage; i <= endPage; i++) {
                html += `<button onclick="goToPage(${i})" class="${i === currentPage ? 'active' : ''}">${i}</button>`;
            }
            
            if (endPage < totalPages) {
                if (endPage < totalPages - 1) html += '<span class="page-info">...</span>';
                html += `<button onclick="goToPage(${totalPages})">${totalPages}</button>`;
            }
            
            // Next button
            html += `<button onclick="goToPage(${currentPage + 1})" ${currentPage === totalPages ? 'disabled' : ''}>Next</button>`;
            
            paginationDiv.innerHTML = html;
        }
        
        // Go to page
        function goToPage(page) {
            const totalPages = Math.ceil(filteredProperties.length / itemsPerPage);
            if (page < 1 || page > totalPages) return;
            
            currentPage = page;
            renderCurrentPage();
            
            // Scroll to top
            window.scrollTo({ top: 0, behavior: 'smooth' });
        }
        
        // Toggle filter dropdown
        function toggleFilterDropdown(event, column) {
            event.stopPropagation();
            const dropdown = document.getElementById(`filter-dropdown-${column}`);
            const btn = document.getElementById(`filter-btn-${column}`);
            
            // Close all other dropdowns
            document.querySelectorAll('.filter-dropdown-content').forEach(d => {
                if (d !== dropdown) d.classList.remove('show');
            });
            
            dropdown.classList.toggle('show');
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(event) {
            if (!event.target.matches('.filter-btn') && !event.target.closest('.filter-dropdown-content')) {
                document.querySelectorAll('.filter-dropdown-content').forEach(dropdown => {
                    dropdown.classList.remove('show');
                });
            }
        });
        
        // Apply column filter
        function applyColumnFilter(column) {
            const checkboxes = document.querySelectorAll(`#${column}-filter-options input[type="checkbox"]:checked`);
            currentFilters[column] = Array.from(checkboxes).map(cb => cb.value);
            
            applyAllFilters();
            
            // Update filter button appearance
            const btn = document.getElementById(`filter-btn-${column}`);
            if (currentFilters[column].length > 0) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
            
            // Close dropdown
            document.getElementById(`filter-dropdown-${column}`).classList.remove('show');
        }
        
        // Clear column filter
        function clearColumnFilter(column) {
            currentFilters[column] = [];
            const checkboxes = document.querySelectorAll(`#${column}-filter-options input[type="checkbox"]`);
            checkboxes.forEach(cb => cb.checked = false);
            
            applyAllFilters();
            
            // Update filter button appearance
            document.getElementById(`filter-btn-${column}`).classList.remove('active');
            
            // Close dropdown
            document.getElementById(`filter-dropdown-${column}`).classList.remove('show');
        }
        
        // Apply all filters
        function applyAllFilters() {
            filteredProperties = allProperties.filter(property => {
                // Filter out hidden properties
                if (hidden.has(property.property_id)) {
                    return false;
                }
                
                // Ward filter
                if (currentFilters.ward.length > 0 && !currentFilters.ward.includes(property.ward)) {
                    return false;
                }
                
                // Primary light filter
                if (currentFilters.primary_light.length > 0 && !currentFilters.primary_light.includes(property.primary_light)) {
                    return false;
                }
                
                // Verdict filter
                if (currentFilters.verdict.length > 0) {
                    const propertyVerdict = property.verdict || property.recommendation || 'pass';
                    if (!currentFilters.verdict.includes(propertyVerdict.toLowerCase())) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Reset to first page and re-sort
            currentPage = 1;
            applySort();
            renderCurrentPage();
        }
        
        // Populate column filters
        function populateColumnFilters() {
            // Ward filter
            const wards = [...new Set(allProperties.map(p => p.ward).filter(Boolean))].sort();
            const wardOptions = document.getElementById('ward-filter-options');
            wardOptions.innerHTML = wards.map(ward => `
                <label>
                    <input type="checkbox" value="${ward}"> ${ward}
                </label>
            `).join('');
            
            // Primary light filter
            const lights = [...new Set(allProperties.map(p => p.primary_light).filter(Boolean))].sort();
            const lightOptions = document.getElementById('primary_light-filter-options');
            lightOptions.innerHTML = lights.map(light => `
                <label>
                    <input type="checkbox" value="${light}"> ${light}
                </label>
            `).join('');
            
            // Verdict filter
            const verdicts = [...new Set(allProperties.map(p => (p.verdict || p.recommendation || 'pass').toLowerCase()))].sort();
            const verdictOptions = document.getElementById('verdict-filter-options');
            verdictOptions.innerHTML = verdicts.map(verdict => `
                <label>
                    <input type="checkbox" value="${verdict}"> ${verdict.toUpperCase()}
                </label>
            `).join('');
        }
        
        // Error banner functions
        function showErrorBanner(message) {
            document.getElementById('errorMessage').textContent = message;
            document.getElementById('errorBanner').style.display = 'flex';
        }
        
        function hideErrorBanner() {
            document.getElementById('errorBanner').style.display = 'none';
        }
        
        // ========== DEBUG HELPER FUNCTIONS ==========
        // These can be called from the browser console for debugging
        
        window.debugFavoritesDisplay = function() {
            console.log('=== FAVORITES DISPLAY DEBUG ===');
            
            // Check tab visibility
            const favTab = document.getElementById('favorites-tab');
            console.log('Favorites Tab:', {
                exists: !!favTab,
                hasActiveClass: favTab?.classList.contains('active'),
                display: favTab?.style.display,
                computedDisplay: favTab ? window.getComputedStyle(favTab).display : null,
                innerHTML: favTab?.innerHTML?.substring(0, 100) + '...'
            });
            
            // Check list element
            const favList = document.getElementById('favoritesList');
            console.log('Favorites List:', {
                exists: !!favList,
                display: favList?.style.display,
                computedDisplay: favList ? window.getComputedStyle(favList).display : null,
                visibility: favList ? window.getComputedStyle(favList).visibility : null,
                opacity: favList ? window.getComputedStyle(favList).opacity : null,
                innerHTML: favList?.innerHTML?.substring(0, 200) + '...',
                childCount: favList?.children?.length,
                textContent: favList?.textContent?.substring(0, 100) + '...'
            });
            
            // Check parent hierarchy
            if (favList) {
                let parent = favList.parentElement;
                let level = 1;
                while (parent && level <= 5) {
                    console.log(`Parent Level ${level}:`, {
                        tagName: parent.tagName,
                        id: parent.id,
                        className: parent.className,
                        display: window.getComputedStyle(parent).display,
                        visibility: window.getComputedStyle(parent).visibility
                    });
                    parent = parent.parentElement;
                    level++;
                }
            }
            
            // Check favorites data
            console.log('Favorites Data:', {
                favoritesSet: [...favorites],
                favoritesCount: favorites.size,
                currentUser: currentUser,
                allPropertiesCount: allProperties.length
            });
            
            // Force display attempt
            console.log('Attempting to force display...');
            if (favTab) {
                favTab.style.display = 'block';
                favTab.style.visibility = 'visible';
                favTab.style.opacity = '1';
            }
            if (favList) {
                favList.style.display = 'block';
                favList.style.visibility = 'visible';
                favList.style.opacity = '1';
            }
            
            console.log('=== END FAVORITES DEBUG ===');
        };
        
        window.debugHiddenDisplay = function() {
            console.log('=== HIDDEN DISPLAY DEBUG ===');
            
            // Check tab visibility
            const hiddenTab = document.getElementById('hidden-tab');
            console.log('Hidden Tab:', {
                exists: !!hiddenTab,
                hasActiveClass: hiddenTab?.classList.contains('active'),
                display: hiddenTab?.style.display,
                computedDisplay: hiddenTab ? window.getComputedStyle(hiddenTab).display : null,
                innerHTML: hiddenTab?.innerHTML?.substring(0, 100) + '...'
            });
            
            // Check list element
            const hiddenList = document.getElementById('hiddenList');
            console.log('Hidden List:', {
                exists: !!hiddenList,
                display: hiddenList?.style.display,
                computedDisplay: hiddenList ? window.getComputedStyle(hiddenList).display : null,
                visibility: hiddenList ? window.getComputedStyle(hiddenList).visibility : null,
                opacity: hiddenList ? window.getComputedStyle(hiddenList).opacity : null,
                innerHTML: hiddenList?.innerHTML?.substring(0, 200) + '...',
                childCount: hiddenList?.children?.length,
                textContent: hiddenList?.textContent?.substring(0, 100) + '...'
            });
            
            // Check parent hierarchy
            if (hiddenList) {
                let parent = hiddenList.parentElement;
                let level = 1;
                while (parent && level <= 5) {
                    console.log(`Parent Level ${level}:`, {
                        tagName: parent.tagName,
                        id: parent.id,
                        className: parent.className,
                        display: window.getComputedStyle(parent).display,
                        visibility: window.getComputedStyle(parent).visibility
                    });
                    parent = parent.parentElement;
                    level++;
                }
            }
            
            // Check hidden data
            console.log('Hidden Data:', {
                hiddenSet: [...hidden],
                hiddenCount: hidden.size,
                allPropertiesCount: allProperties.length
            });
            
            // Force display attempt
            console.log('Attempting to force display...');
            if (hiddenTab) {
                hiddenTab.style.display = 'block';
                hiddenTab.style.visibility = 'visible';
                hiddenTab.style.opacity = '1';
            }
            if (hiddenList) {
                hiddenList.style.display = 'block';
                hiddenList.style.visibility = 'visible';
                hiddenList.style.opacity = '1';
            }
            
            console.log('=== END HIDDEN DEBUG ===');
        };
        
        // Quick function to manually reload favorites
        window.reloadFavorites = async function() {
            console.log('Manually reloading favorites...');
            await loadFavorites();
            console.log('Favorites reload complete');
        };
        
        // Quick function to manually reload hidden
        window.reloadHidden = function() {
            console.log('Manually reloading hidden...');
            loadHidden();
            console.log('Hidden reload complete');
        };
        
    </script>
</body>
</html>