"""
Tests for Report Sender Lambda function.
"""
import json
from unittest.mock import patch, Mock

import pytest
import responses

# Import the report sender function
import sys
sys.path.append('/mnt/c/Users/azure/Desktop/scraper/lambda/report_sender')
from app import lambda_handler, generate_markdown_report, send_to_slack, send_via_email, markdown_to_plain_text


class TestReportSender:
    """Test cases for Report Sender Lambda function."""
    
    def test_lambda_handler_success(self, mock_s3_client, mock_ses_client, environment_variables, sample_report_event):
        """Test successful report generation and sending."""
        with patch('app.s3_client', mock_s3_client), \
             patch('app.ses_client', mock_ses_client), \
             patch('app.send_to_slack', return_value=True), \
             patch('app.send_via_email', return_value=True):
            
            result = lambda_handler(sample_report_event, None)
        
        assert result['statusCode'] == 200
        assert result['date'] == '2025-07-07'
        assert result['top_picks_count'] == 1
        assert result['slack_sent'] is True
        assert result['email_sent'] is True
        
        # Verify report was saved to S3
        response = mock_s3_client.get_object(Bucket='test-bucket', Key=result['report_key'])
        report_content = response['Body'].read().decode('utf-8')
        assert 'Tokyo Real Estate Analysis - 2025-07-07' in report_content
        assert 'listing1' in report_content
    
    def test_lambda_handler_no_picks(self, mock_s3_client, environment_variables):
        """Test handling when no top picks are found."""
        event = {
            'date': '2025-07-07',
            'bucket': 'test-bucket',
            'batch_result': {
                'top_picks': [],
                'runners_up': [],
                'market_notes': ''
            }
        }
        
        with patch('app.s3_client', mock_s3_client):
            result = lambda_handler(event, None)
        
        assert result['statusCode'] == 200
        assert 'No top picks found' in result['message']
    
    def test_generate_markdown_report_complete(self, sample_report_event):
        """Test Markdown report generation with complete data."""
        batch_result = sample_report_event['batch_result']
        
        markdown = generate_markdown_report(batch_result, '2025-07-07')
        
        # Check header
        assert '# Tokyo Real Estate Analysis - 2025-07-07' in markdown
        assert '**Top Picks**: 1' in markdown
        assert '**Runners Up**: 1' in markdown
        
        # Check market notes
        assert '## Market Overview' in markdown
        assert 'Strong demand in central Tokyo areas' in markdown
        
        # Check top picks table
        assert '## üèÜ Top 5 Picks' in markdown
        assert '| Rank | ID | Score |' in markdown
        assert '| 1 | listing1 | 85 |' in markdown
        
        # Check detailed analysis
        assert '#### 1. Property listing1 (Score: 85)' in markdown
        assert 'Great value in prime location' in markdown
        assert 'üö© Red Flags' in markdown
        assert 'Minor wear on floors' in markdown
        
        # Check runners up
        assert '## ü•à Runners Up' in markdown
        assert 'listing2' in markdown
        
        # Check footer
        assert 'ü§ñ *Generated by AI Real Estate Analysis System*' in markdown
    
    def test_generate_markdown_report_minimal(self):
        """Test Markdown report generation with minimal data."""
        minimal_result = {
            'top_picks': [
                {
                    'id': 'listing1',
                    'score': 75,
                    'why': 'Good deal'
                }
            ],
            'runners_up': [],
            'market_notes': ''
        }
        
        markdown = generate_markdown_report(minimal_result, '2025-07-07')
        
        assert '# Tokyo Real Estate Analysis - 2025-07-07' in markdown
        assert '**Top Picks**: 1' in markdown
        assert '**Runners Up**: 0' in markdown
        assert '## Market Overview' not in markdown  # No market notes
        assert '## ü•à Runners Up' not in markdown  # No runners up
    
    @responses.activate
    def test_send_to_slack_success(self, mock_ssm_client, environment_variables):
        """Test successful Slack message sending."""
        # Mock Slack webhook response
        responses.add(
            responses.POST,
            'https://hooks.slack.com/test',
            json={'ok': True},
            status=200
        )
        
        markdown_report = "# Test Report\n\nThis is a test report."
        
        with patch('app.ssm_client', mock_ssm_client):
            result = send_to_slack(markdown_report, '2025-07-07')
        
        assert result is True
        assert len(responses.calls) == 1
        
        # Check request payload
        request_body = json.loads(responses.calls[0].request.body)
        assert request_body['text'] == 'Tokyo Real Estate Analysis - 2025-07-07'
        assert len(request_body['blocks']) == 1
    
    @responses.activate
    def test_send_to_slack_failure(self, environment_variables):
        """Test Slack sending failure handling."""
        # Mock failed Slack webhook response
        responses.add(
            responses.POST,
            'https://hooks.slack.com/test',
            json={'error': 'invalid_payload'},
            status=400
        )
        
        markdown_report = "# Test Report\n\nThis is a test report."
        
        result = send_to_slack(markdown_report, '2025-07-07')
        
        assert result is False
    
    def test_send_to_slack_no_url(self, environment_variables):
        """Test Slack sending when no webhook URL is configured."""
        with patch.dict('os.environ', {'SLACK_HOOK_URL': ''}):
            with patch('app.ssm_client') as mock_ssm:
                mock_ssm.get_parameter.return_value = {'Parameter': {'Value': ''}}
                
                result = send_to_slack("Test report", '2025-07-07')
        
        assert result is False
    
    def test_send_via_email_success(self, mock_ses_client, environment_variables):
        """Test successful email sending."""
        markdown_report = "# Test Report\n\n**Bold text** and *italic text*."
        
        with patch('app.ses_client', mock_ses_client):
            mock_ses_client.send_email.return_value = {'MessageId': 'test-message-id'}
            
            result = send_via_email(markdown_report, '2025-07-07')
        
        assert result is True
        
        # Verify SES call
        mock_ses_client.send_email.assert_called_once()
        call_args = mock_ses_client.send_email.call_args[1]
        
        assert call_args['Source'] == 'test@example.com'
        assert call_args['Destination']['ToAddresses'] == ['recipient@example.com']
        assert call_args['Message']['Subject']['Data'] == 'Tokyo Real Estate Analysis - 2025-07-07'
        
        # Check that both text and HTML versions are included
        assert 'Text' in call_args['Message']['Body']
        assert 'Html' in call_args['Message']['Body']
    
    def test_send_via_email_no_config(self, environment_variables):
        """Test email sending when email addresses are not configured."""
        with patch.dict('os.environ', {'EMAIL_FROM': '', 'EMAIL_TO': ''}):
            result = send_via_email("Test report", '2025-07-07')
        
        assert result is False
    
    def test_send_via_email_failure(self, mock_ses_client, environment_variables):
        """Test email sending failure handling."""
        with patch('app.ses_client', mock_ses_client):
            mock_ses_client.send_email.side_effect = Exception('SES error')
            
            result = send_via_email("Test report", '2025-07-07')
        
        assert result is False
    
    def test_markdown_to_plain_text(self):
        """Test Markdown to plain text conversion."""
        markdown = """# Header 1
## Header 2
**Bold text** and *italic text*
`inline code`
[Link text](http://example.com)
| Table | Header |
|-------|--------|
| Cell  | Data   |
        """
        
        plain_text = markdown_to_plain_text(markdown)
        
        # Headers should be cleaned
        assert 'Header 1' in plain_text
        assert 'Header 2' in plain_text
        assert '# Header 1' not in plain_text
        assert '## Header 2' not in plain_text
        
        # Formatting should be removed
        assert 'Bold text' in plain_text
        assert 'italic text' in plain_text
        assert '**Bold text**' not in plain_text
        assert '*italic text*' not in plain_text
        
        # Links should show only text
        assert 'Link text' in plain_text
        assert 'http://example.com' not in plain_text
        
        # Inline code should be cleaned
        assert 'inline code' in plain_text
        assert '`inline code`' not in plain_text
    
    def test_lambda_handler_load_from_s3(self, mock_s3_client, environment_variables):
        """Test loading batch results from S3 when not provided in event."""
        # Set up batch results in S3
        batch_result = {
            'parsed_result': {
                'top_picks': [
                    {
                        'id': 'listing1',
                        'score': 80,
                        'why': 'Good value'
                    }
                ],
                'runners_up': [],
                'market_notes': 'Test notes'
            }
        }
        
        mock_s3_client.put_object(
            Bucket='test-bucket',
            Key='batch_output/2025-07-07/response.json',
            Body=json.dumps(batch_result).encode('utf-8')
        )
        
        event = {
            'date': '2025-07-07',
            'bucket': 'test-bucket',
            'result_key': 'batch_output/2025-07-07/response.json'
        }
        
        with patch('app.s3_client', mock_s3_client), \
             patch('app.send_to_slack', return_value=True), \
             patch('app.send_via_email', return_value=True):
            
            result = lambda_handler(event, None)
        
        assert result['statusCode'] == 200
        assert result['top_picks_count'] == 1